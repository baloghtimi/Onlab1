/**
 * generated by Xtext 2.12.0
 */
package org.mondo.collaboration.policy.scoping;

import com.google.common.base.Objects;
import com.google.common.collect.Iterators;
import com.google.common.collect.Lists;
import java.util.ArrayList;
import org.eclipse.emf.common.notify.Notifier;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EEnumLiteral;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.viatra.query.patternlanguage.emf.eMFPatternLanguage.ClassType;
import org.eclipse.viatra.query.patternlanguage.patternLanguage.Pattern;
import org.eclipse.viatra.query.patternlanguage.patternLanguage.Type;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.mondo.collaboration.policy.rules.AttributeFact;
import org.mondo.collaboration.policy.rules.Binding;
import org.mondo.collaboration.policy.rules.Import;
import org.mondo.collaboration.policy.rules.Model;
import org.mondo.collaboration.policy.rules.ObjectFact;
import org.mondo.collaboration.policy.rules.OperationType;
import org.mondo.collaboration.policy.rules.ReferenceFact;
import org.mondo.collaboration.policy.rules.Rule;
import org.mondo.collaboration.policy.rules.RulesPackage;
import org.mondo.collaboration.policy.scoping.AbstractRulesScopeProvider;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class RulesScopeProvider extends AbstractRulesScopeProvider {
  @Override
  public IScope getScope(final EObject context, final EReference reference) {
    EAttribute _rule_Operation = RulesPackage.eINSTANCE.getRule_Operation();
    boolean _equals = Objects.equal(reference, _rule_Operation);
    if (_equals) {
      if ((context instanceof Rule)) {
        final ArrayList<EEnumLiteral> literals = Lists.<EEnumLiteral>newArrayList();
        EList<EEnumLiteral> _eLiterals = RulesPackage.eINSTANCE.getOperationType().getELiterals();
        for (final EEnumLiteral literal : _eLiterals) {
          boolean _equals_1 = literal.getLiteral().equals(OperationType.UNSET);
          boolean _not = (!_equals_1);
          if (_not) {
            literals.add(literal);
          }
        }
        return Scopes.scopeFor(literals);
      }
    }
    if ((Objects.equal(reference, RulesPackage.eINSTANCE.getRule_Pattern()) && (context instanceof Rule))) {
      return this.scopeRule_Pattern(context, reference);
    }
    if ((((((Objects.equal(reference, RulesPackage.eINSTANCE.getBinding_Variable()) && (context instanceof Binding)) || (Objects.equal(reference, RulesPackage.eINSTANCE.getObjectFact_Variable()) && (context instanceof ObjectFact))) || (Objects.equal(reference, RulesPackage.eINSTANCE.getReferenceFact_SourceVar()) && (context instanceof ReferenceFact))) || (Objects.equal(reference, RulesPackage.eINSTANCE.getReferenceFact_TargetVar()) && (context instanceof ReferenceFact))) || (Objects.equal(reference, RulesPackage.eINSTANCE.getAttributeFact_Variable()) && (context instanceof AttributeFact)))) {
      return this.scopeVariable(context, reference);
    }
    if ((Objects.equal(reference, RulesPackage.eINSTANCE.getReferenceFact_Reference()) && (context instanceof ReferenceFact))) {
      return this.scopeReferenceFact_Reference(context, reference);
    }
    if ((Objects.equal(reference, RulesPackage.eINSTANCE.getAttributeFact_Attribute()) && (context instanceof AttributeFact))) {
      return this.scopeAttributeFact_Attribute(context, reference);
    }
    return super.getScope(context, reference);
  }
  
  public TreeIterator<Notifier> queries(final EObject context) {
    EObject _get = context.eResource().getContents().get(0);
    final Model model = ((Model) _get);
    final ResourceSet resourceSet = context.eResource().getResourceSet();
    EList<Import> _imports = model.getImports();
    for (final Import im : _imports) {
      resourceSet.getResource(URI.createFileURI(im.getImportURI()), true);
    }
    return resourceSet.getAllContents();
  }
  
  public IScope scopeRule_Pattern(final EObject context, final EReference reference) {
    return Scopes.scopeFor(IteratorExtensions.<Pattern>toList(Iterators.<Pattern>filter(this.queries(context), Pattern.class)));
  }
  
  public IScope scopeVariable(final EObject context, final EReference reference) {
    EObject _eContainer = context.eContainer();
    final Rule rule = ((Rule) _eContainer);
    return Scopes.scopeFor(rule.getPattern().getParameters());
  }
  
  public IScope scopeReferenceFact_Reference(final EObject context, final EReference reference) {
    final ReferenceFact refFact = ((ReferenceFact) context);
    Type _type = refFact.getSourceVar().getType();
    final ClassType sourceClassType = ((ClassType) _type);
    Type _type_1 = refFact.getTargetVar().getType();
    final ClassType targetClassType = ((ClassType) _type_1);
    EClassifier _classname = sourceClassType.getClassname();
    final EClass sourceParamClass = ((EClass) _classname);
    EClassifier _classname_1 = targetClassType.getClassname();
    final EClassifier targetParamClassifier = ((EClassifier) _classname_1);
    final ArrayList<EReference> refs = Lists.<EReference>newArrayList();
    EList<EReference> _eAllReferences = sourceParamClass.getEAllReferences();
    for (final EReference ref : _eAllReferences) {
      EClassifier _eType = ref.getEType();
      boolean _equals = Objects.equal(_eType, targetParamClassifier);
      if (_equals) {
        refs.add(ref);
      }
    }
    return Scopes.scopeFor(refs);
  }
  
  public IScope scopeAttributeFact_Attribute(final EObject context, final EReference reference) {
    final AttributeFact attrFact = ((AttributeFact) context);
    Type _type = attrFact.getVariable().getType();
    final ClassType varClassType = ((ClassType) _type);
    EClassifier _classname = varClassType.getClassname();
    final EClass varClass = ((EClass) _classname);
    return Scopes.scopeFor(varClass.getEAllAttributes());
  }
}
