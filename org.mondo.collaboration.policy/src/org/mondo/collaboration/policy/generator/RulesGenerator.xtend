/*
 * generated by Xtext 2.10.0
 */
package org.mondo.collaboration.policy.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.mondo.collaboration.policy.rules.Model
import org.mondo.collaboration.policy.rules.Rule
import org.mondo.collaboration.policy.rules.Policy
import org.mondo.collaboration.policy.rules.OperationType
import org.mondo.collaboration.policy.rules.AccessibilityLevel
import org.eclipse.viatra.query.patternlanguage.patternLanguage.Variable
import java.util.List
import org.mondo.collaboration.policy.rules.Binding
import java.util.ArrayList
import org.mondo.collaboration.policy.rules.ObjectFact
import org.mondo.collaboration.policy.rules.AttributeFact
import org.mondo.collaboration.policy.rules.ReferenceFact
import org.mondo.collaboration.policy.rules.User
import org.mondo.collaboration.policy.rules.Group
import org.mondo.collaboration.policy.rules.Role
import java.util.TreeSet
import org.mondo.collaboration.policy.rules.ResolutionType

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class RulesGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val model = resource.contents.head as Model;
		val priorities = model.priorities;
		fsa.generateFile(resource.className+"_gen.vql", generateVQL(model, priorities));
	}
	
	def className(Resource resource) {
		var name = resource.URI.lastSegment
		return name.substring(0, name.indexOf('.'))
	}
	
	def generateVQL(Model model, Iterable<Integer> priorities) '''
package org.mondo.collaboration.security.increment.policy
	
import "http://www.eclipse.org/emf/2002/Ecore"
import "http://mondo.org/collaboration/security/increment/vocabulary"

pattern readWriteOperation(operation) = {
	operation == OperationType::READ;
} or {
	operation == OperationType::WRITE;
}

«FOR rule: model.policy.rules SEPARATOR "\n\n" AFTER "\n"»
pattern «rule.name»Asset(«rule.objectAsset»: EObject) {
	find «rule.pattern.name»(«FOR bind: rule.bindList SEPARATOR ", " AFTER ");"»«bind»«ENDFOR»
}

pattern «rule.name»User(user: java String) {
	«FOR user: rule.roles.usersOfRoleList SEPARATOR "\n} or {" AFTER "}"»
	user == "«user.name»";
	«ENDFOR»
«ENDFOR»

pattern allUsers(user: java String) {
	«FOR user: model.roles.usersOfRoleList SEPARATOR "\n} or {" AFTER "}"»
	user == "«user.name»";
	«ENDFOR»

pattern explicitJudgement(user: java String, asset: EObject, operation, access, priority: java Integer)
{
	
«FOR rule: model.policy.rules SEPARATOR "\n\n} or {\n" AFTER "\n} or {\n"»
«rule.generateRulePattern»
«ENDFOR»

«model.policy.generateDefaultPattern»
}

pattern effectiveJudgement(user: java String, asset: EObject, operation, access) 
{
	«FOR prio: priorities SEPARATOR "\n} or {" »
	find effectiveJudgement_at_«prio»(user, asset, operation, access);
	«ENDFOR»
}

«FOR prio: priorities»
pattern judgement_at_«prio»(user: java String, asset: EObject, operation, access) 
{
	find explicitJudgement(user, asset, operation, access, «prio»);
«IF prio != priorities.maxBy[it]»
} or {
	find relaxedJudgement_at_«prio»(user, asset, operation, access);
«ENDIF»
} or {
	find strongConsequence_at_«prio»(user, asset, operation, access, _domAsset, _domOp, _domAccess);
	«FOR domPrio: priorities»«IF domPrio >= prio»
//} or {
//	find weakConsequence_at_«prio»_of_«domPrio»(user, asset, operation, access, _domAsset, _domOp, _domAccess);
	«ENDIF»«ENDFOR»
}
«ENDFOR»

«FOR prio: priorities»«IF prio != priorities.maxBy[it]»
pattern relaxedJudgement_at_«prio»(user: java String, asset: EObject, operation, access)
{
	find judgement_at_«prio»(user, asset, operation, dominatedAccess);
	find domination_of_«prio»(user, asset, operation, _dominatedAccess, access);
}
«ENDIF»«ENDFOR»

«FOR prio: priorities»
pattern effectiveJudgement_at_«prio»(user: java String, asset: EObject, operation, access) 
{
	find judgement_at_«prio»(user, asset, operation, access);
	«IF prio != priorities.maxBy[it]»
	neg find domination_of_«prio»(user, asset, operation, access, _prevailingAccess);
	«ENDIF»
} 
«ENDFOR»

«FOR prio: priorities»«IF prio != priorities.maxBy[it]»
pattern domination_of_«prio»(user: java String, asset: EObject, operation, dominatedAccess, prevailingAccess) 
{
	«FOR prevailingPrio: priorities.filter[it > prio] SEPARATOR "\n} or {" »
	find domination_by_«prevailingPrio»(user, asset, operation, dominatedAccess, prevailingAccess);
	«ENDFOR»
} 
«ENDIF»«ENDFOR»

«FOR prevailingPrio: priorities»«IF prevailingPrio != priorities.minBy[it]»
pattern domination_by_«prevailingPrio»(user: java String, asset: EObject, operation, dominatedAccess, prevailingAccess) 
{
	find effectiveJudgement_at_«prevailingPrio»(user, asset, operation, prevailingAccess);
	find resolution(dominatedAccess, prevailingAccess);
}  
«ENDIF»«ENDFOR»

pattern resolution(dominatedAccess, prevailingAccess)
{
	«IF model.policy.resolution == ResolutionType.RESTRICTIVE»
	dominatedAccess == AccessibilityLevel::ALLOW;
	prevailingAccess == AccessibilityLevel::DENY;
	«ENDIF»
	«IF model.policy.resolution == ResolutionType.PERMISSIVE»
	dominatedAccess == AccessibilityLevel::DENY;
	prevailingAccess == AccessibilityLevel::ALLOW;
	«ENDIF»
}

«FOR prio: priorities»
pattern strongConsequence_at_«prio»(user: java String,
	depAsset: EObject, depOp, depAccess, 
	domAsset: EObject, domOp, domAccess) 
{
	// type II, read vs write
	find effectiveJudgement_at_«prio»(user, domAsset, domOp, domAccess);
	depAsset == domAsset;
	domOp == OperationType::WRITE; depOp == OperationType::READ;
	domAccess == AccessibilityLevel::ALLOW; depAccess == AccessibilityLevel::ALLOW; 
} or {
	// type II, read vs write
	find effectiveJudgement_at_«prio»(user, domAsset, domOp, domAccess);
	depAsset == domAsset;
	domOp == OperationType::READ; depOp == OperationType::WRITE;
	domAccess == AccessibilityLevel::DENY; depAccess == AccessibilityLevel::DENY; 
} or {
	// type III, read vs containment
	find effectiveJudgement_at_«prio»(user, domAsset, domOp, domAccess);
	find contains(depAsset, domAsset);
	domOp == OperationType::READ; depOp == OperationType::READ;
	domAccess == AccessibilityLevel::ALLOW; depAccess == AccessibilityLevel::ALLOW; 
} or {
	// type III, read vs containment
	find effectiveJudgement_at_«prio»(user, domAsset, domOp, domAccess);
	find contains(domAsset, depAsset);
	domOp == OperationType::READ; depOp == OperationType::READ;
	domAccess == AccessibilityLevel::DENY; depAccess == AccessibilityLevel::DENY; 
}
«ENDFOR»

//pattern weakConsequence(user: java String,
//	depAsset: EObject, depOp: java SecurityOperation, depBound: java Enumerator, 
//	dir: java BoundDirection, depPrio: java Integer,
//	domAsset: EObject, domOp: java SecurityOperation, domBound: java Enumerator,
//	domPrio: java Integer) 
//{
//	depPrio == 1;
//	// TODO implement; not needed for example
//}
'''	

    def generateRulePattern(Rule rule) '''
    //  rule «rule.name»
        find «rule.name»Asset(asset);
        find «rule.name»User(user);
        «rule.operation.generateOperationType»
        «rule.access.generateAccessibilityLevel»
        priority == «rule.priority»;
    '''

    def generateDefaultPattern(Policy policy) '''
    //  rule default
        find objectAllObjects(asset);
        find allUsers(user);
        «policy.operation.generateOperationType»
        «policy.access.generateAccessibilityLevel»
        priority == 0;
    '''

    def generateOperationType(OperationType operation) '''
        «IF operation == OperationType.READWRITE»
        find readWriteOperation(operation);
        «ENDIF»
        «IF operation == OperationType.READ»
        operation == OperationType::READ;
        «ENDIF»
        «IF operation == OperationType.WRITE»
        operation == OperationType::WRITE;
        «ENDIF»
    '''

    def generateAccessibilityLevel(AccessibilityLevel access) '''
        «IF access == AccessibilityLevel.ALLOW»
        access == AccessibilityLevel::ALLOW;
        «ENDIF»
        «IF access == AccessibilityLevel.DENY»
        access == AccessibilityLevel::DENY;
        «ENDIF»
    '''

    def getObjectAsset(Rule rule) {
    	val object = rule.asset as ObjectFact;
    	return object.variable.name;
    }

    def getBindList(Rule rule) {
		val bindList = new ArrayList<Object>();
		for (Variable parameter : rule.pattern.parameters) {
			bindList.add(getBindValue(parameter, rule));
		}
		return bindList;
	}
	
	def getBindValue(Variable parameter, Rule rule) {
		for(Binding binding : rule.bindings) {
			if(binding.variable.equals(parameter)){
				if(binding.bind.valueString !== null) {
					return binding.bind.valueString;
				} else {
					return binding.bind.valueInteger;
				}
			}
		}
		if(rule.asset instanceof ObjectFact) {
			val objectAsset = rule.asset as ObjectFact;
			if(objectAsset.variable.equals(parameter)) {
				return objectAsset.variable.name;
			}
		}
		if(rule.asset instanceof AttributeFact) {
			val attributeAsset = rule.asset as AttributeFact;
			if(attributeAsset.variable.equals(parameter)) {
				return attributeAsset.variable.name;
			}
		}
		if(rule.asset instanceof ReferenceFact) {
			val referenceAsset = rule.asset as ReferenceFact;
			if(referenceAsset.sourceVar.equals(parameter)) {
				return referenceAsset.sourceVar.name;
			}
			if(referenceAsset.targetVar.equals(parameter)) {
				return referenceAsset.targetVar.name;
			}
		}
		return "_";
	}
	
	def getUsersOfRoleList(List<Role> roles) {
		val userList = new ArrayList<User>();
		for (Role role : roles) {
			if(role instanceof User) {
				userList.add(role as User);
			} else {
				for (user : getUsersOfGroup(role as Group)) {
					userList.add(user);
				}
			}
		}
		return userList;
	}
	
	def List<User> getUsersOfGroup(Group group){
		val userList = new ArrayList<User>();
		for (role : group.roles) {
			if(role instanceof User){
			    userList.add(role as User);
			} else {
				userList.addAll(getUsersOfGroup(role as Group));
			}
		}
		return userList;
	}
	
	def getPriorities(Model model) {
		val priorities = new TreeSet<Integer>();
		priorities.add(0);
		for(rule : model.policy.rules) {
			priorities.add(rule.priority);
		}
		return priorities;
	}
}
